#!/usr/bin/env python3
import sys
import argparse
import numpy as np
import configparser
from nanocut import *

BODYOBJECTS = {
    "0D": {
           "sphere": sphere.Sphere,
           "convex_polyhedron": polyhedron.Polyhedron,
           "cylinder": cylinder.Cylinder,
           },
    "1D": {
           "periodic_1D_cylinder": periodic_1D_cylinder.Periodic1DCylinder,
           "periodic_1D_prism": periodic_1D_prism.Periodic1DPrism,
           },
    "2D": {
           "periodic_2D_plane": periodic_2D_plane.Periodic2DPlane,
           }
    }


def parse_args():
    """Builds parser and returns parsed command line.
    
    Returns:
        Parsed command line as Namespace object.
    """
    parser = argparse.ArgumentParser(
        description="Cuts out various 0D, 1D and 2D shapes from crystals.")
    parser.add_argument("-a", "--append", action="store_true", default=False,
                        help="appends created structure to output file "
                        "(instead of overwriting it)")
    parser.add_argument("-v", "--verbosity", default=1, type=int,
                        help="Set verbosity level: 0 - no output, 1 - normal "
                        "output (default)")
    parser.add_argument("inifile", help="initialization file")
    parser.add_argument("resultxyz",
                        help="file containing resulting structure in xyz "
                        "format")
    return parser.parse_args()


def process_arguments(args):
    output.set_verbosity(args.verbosity)


def read_inifile(filename):
    """Reads configuration file and returns it as nested dictionary.
    
    Args:
        filename: Name of the file with the configuration.
    """
    ini = configparser.ConfigParser()
    try:
        configfile = open(filename, "r")
    except IOError:
        sys.exit("Error: Can't open " + filename + ".\nExiting")
    try:
        ini.readfp(configfile)
    except configparser.Error as error:
        sys.exit("Error: Malformed ini-file:\n" + str(error) + "\nExiting")
    configfile.close()
    return ini
     

def getbodies(configdict, allowed_bodies, geometry, period):
    """Initializes body object based on the input.
    
    Args:
        configdict: Dictionary with configuration options.
        allowed_bodies: Dictionary with allowed body objects.
        geometry: Geometry object.
        period: Periodicity object.
        
    Returns:
       List of tuples with initialized body objects and flag signalizing whether
       body is additive or not.
    """
    bodies = []
    tmp = []
    for section in configdict:
        words = section.split(":")
        if len(words) != 2:
            continue
        bodyobj = allowed_bodies.get(words[0], None)
        if bodyobj is None:
            output.error("Body type '" + words[0] + "' unknown or incompatible "
                         " with periodicity")
        additive = configdict[section].getboolean("additive", fallback=True)
        bodies.append(
            ( bodyobj.fromdict(geometry, period, configdict[section]),
              additive ))
    if not bodies:
        output.error("No bodies specified.")
    return bodies


def getatomsinside(bodies, geo):
    """Selects the atoms in the final structure.
    
    Args:
        bodies: Bodies to consider and their additivity flag.
        geo: Basic crystall geometry
        
    Returns:
        Cartesian position of the atoms in the final structure.
    """
    output.printstatus("Determining boundaries of the lattice grid")
    # Get boundaries of the cuboid containing all bodies
    cuboid_boundaries = np.vstack(
        [ body.containing_cuboid() for body, additive in bodies if additive ])
    cuboid_boundaries = np.array([ cuboid_boundaries.min(axis=0),
                                   cuboid_boundaries.max(axis=0)])

    # Generate lattice-cuboid and all atoms in it
    output.printstatus("Creating all lattice grid points")
    lattice_cuboid = geo.gen_cuboid(cuboid_boundaries)
    
    output.printstatus("Filtering atoms inside specified bodies")
    atoms_coords, atoms_idx = geo.gen_atoms(lattice_cuboid)
    atoms_inside_bodies = np.zeros(len(atoms_coords), dtype=bool)
    for body, additive in bodies:
        tmp_atoms_inside_bodies = body.atoms_inside(atoms_coords)
        
        # Add or substract them respectively
        if additive:
            atoms_inside_bodies = atoms_inside_bodies + tmp_atoms_inside_bodies
        else:
            atoms_inside_bodies = (atoms_inside_bodies 
                                   + tmp_atoms_inside_bodies
                                   - tmp_atoms_inside_bodies)
    # Take only atoms flagged being inside
    return atoms_coords[atoms_inside_bodies], atoms_idx[atoms_inside_bodies]


def main():
    """Main program."""
 
    # Parse command line parameters
    args = parse_args()
    process_arguments(args)
    
    # Print header (delayed, so that it can be suppressed via cmd line option)
    output.printheader()
     
    # Read initial file
    output.printstatus("Parsing config file '{}'".format(args.inifile))
    configdict = read_inifile(args.inifile)

    # Process crystal geometry
    geo = geometry.Geometry.fromdict(configdict)
    
    # Process periodicity
    period = periodicity.Periodicity.fromdict(geo, configdict)
    
    # Process bodies
    bodies = getbodies(configdict, BODYOBJECTS[period.period_type], geo, period)
    
    # Select atoms in the desired shape (first fold atoms into unit cell)
    atoms_coords, atoms_idx = getatomsinside(bodies, geo)

    # Fold atoms to unit cell and rotate to standard form
    output.printstatus("Rotating coordinate system to standard form "
                       "(if necessary)")
    period.arrange_positions(atoms_coords)
    axis_string, atoms_coords = period.rotate_coordsys(atoms_coords)

    # Write object to file
    output.printstatus("Writing result to file '{}'".format(args.resultxyz))
    output.write_crystal(geo,atoms_coords, atoms_idx, axis_string,
                         args.resultxyz, args.append)
    
    output.printstatus("Done.")


if __name__ == "__main__":
    main()
